From 9498e9ff8ec42aa869163d09086b240386eac281 Mon Sep 17 00:00:00 2001
From: Axel Rutz <axel.rutz@clever-systems.net>
Date: Mon, 9 May 2011 01:32:07 +0200
Subject: [PATCH] first shot of fix for #1144074 - date validation with multistep and #access=false

---
 date_elements.inc            |   61 +++++++++++++++++++++++++++++++++---------
 date_popup/date_popup.module |   30 +++++++++++++++++---
 2 files changed, 73 insertions(+), 18 deletions(-)

diff --git a/date_elements.inc b/date_elements.inc
index baedac7..1c705dd 100644
--- a/date_elements.inc
+++ b/date_elements.inc
@@ -106,9 +106,38 @@ function date_field_widget_form(&$form, &$form_state, $field, $instance, $langco
 }
 
 function date_combo_value_callback($element, $input = FALSE, &$form_state) {
-  if (!$input) {
-    return array();
+  // inspired by date_popup_element_value_callback()
+  // TODO: add granularity, see date_popup_input_date
+  if ($input) {
+    $return = $input;
+  } elseif (!empty($element['#default_value'])) {
+    // inspired by date_combo_element_process()
+    // as we dont have $element['#date_format'] here
+    // TODO: shouldn't this be done at form build time?
+    $field = field_widget_field($element, $form_state);
+    $instance = field_widget_instance($element, $form_state);
+    $element['#date_format'] = date_limit_format(date_input_format($element, $field, $instance), $field['settings']['granularity']);
+
+    $granularity = date_format_order($element['#date_format']);
+    $has_time = date_has_time($granularity);
+    $flexible = !empty($element['#date_flexible']) ? $element['#date_flexible'] : 0;
+    
+    $format = date_popup_date_format($element);
+    $format .= $has_time ? ' ' . date_popup_time_format($element) : '';
+    
+    // FIXME: we should not hardcode the output format of the popup widget here, 
+    // but rely on the #value_callback of our children...
+    // but they seem lost here and no way to know who they are...
+    foreach(array('value', 'value2') as $part) {
+      $date = new DateObject($element['#default_value'][$part], $element['#date_timezone']);
+      $return[$part]['date'] = is_object($date) ? $date->format('d.m.Y') : '';
+      $return[$part]['time'] = is_object($date) ? $date->format('H:i') : '';
+    }
   }
+  
+  // dsm(get_defined_vars(), __FUNCTION__);
+  
+  return $return;
 }
 
 /**
@@ -186,17 +215,16 @@ function date_local_date($form, $form_state, $delta, $item, $timezone, $field, $
  * Process an individual date element.
  */
 function date_combo_element_process($element, &$form_state, $form) {
-  if (isset($element['#access']) && empty($element['#access'])) {
-    return;
-  }
-
+  /* if (isset($element['#access']) && empty($element['#access'])) {
+    return $element;
+  } */
   $field_name = $element['#field_name'];
   $delta = $element['#delta'];
   $bundle = $element['#bundle'];
   $entity_type = $element['#entity_type'];
   $field = field_widget_field($element, $form_state);
   $instance = field_widget_instance($element, $form_state);
-
+  
   $columns = $element['#columns'];
   if (isset($columns['rrule'])) {
     unset($columns['rrule']);
@@ -326,8 +354,12 @@ function date_combo_validate($element, &$form_state) {
 
   // Repeating dates have a different form structure, so get the
   // right item values.
-  $item = isset($form_values[$field_name][$langcode]['rrule']) ? $form_values[$field_name][$langcode] : $form_values[$field_name][$langcode][$delta];
-  $posted = isset($form_values[$field_name][$langcode]['rrule']) ? $form_input[$field_name][$langcode] : $form_input[$field_name][$langcode][$delta];
+  // $item = isset($form_values[$field_name][$langcode]['rrule']) ? $form_values[$field_name][$langcode] : $form_values[$field_name][$langcode][$delta];
+  // $posted = isset($form_values[$field_name][$langcode]['rrule']) ? $form_input[$field_name][$langcode] : $form_input[$field_name][$langcode][$delta];
+  // EDIT: no, we have to comply to form api structure and rely on values that 
+  // #value_callback sends us (fixed now) , and we have to be ignoring above.
+  // issues with repeating dates have to be fixed there.
+  $item = $element['#value'];
 
   $field = field_widget_field($element, $form_state);
   $instance = field_widget_instance($element, $form_state);
@@ -389,16 +421,19 @@ function date_combo_validate($element, &$form_state) {
   // Don't look for further errors if errors are already flagged
   // because otherwise we'll show errors on the nested elements
   // more than once.
-  elseif (!form_get_errors()) {
+  // TODO: this only makes sense for sub-errors, so disabling for now
+  elseif (TRUE || !form_get_errors()) {
 
+    // dsm(get_defined_vars(), __FUNCTION__);
+  
     // Check todate input for blank values and substitute in fromdate
     // values where needed, then re-compute the todate with those values.
     if ($field['settings']['todate']) {
       $merged_date = array();
       $to_date_empty = TRUE;
-      foreach ($posted[$to_field] as $part => $value) {
+      foreach ($item[$to_field] as $part => $value) {
         $to_date_empty = $to_date_empty && empty($value) && !is_numeric($value);
-        $merged_date[$part] = empty($value)  && !is_numeric($value) ? $posted[$from_field][$part] : $value;
+        $merged_date[$part] = empty($value)  && !is_numeric($value) ? $item[$from_field][$part] : $value;
         if ($part == 'ampm' && $merged_date['ampm'] == 'pm' && $merged_date['hour'] < 12) {
           $merged_date['hour'] += 12;
         }
@@ -428,7 +463,7 @@ function date_combo_validate($element, &$form_state) {
     $timezone = !empty($item[$tz_field]) ? $item[$tz_field] : $element['#date_timezone'];
     $timezone_db = date_get_timezone_db($field['settings']['tz_handling']);
     $element[$from_field]['#date_timezone'] = $timezone;
-    $from_date = date_input_date($field, $instance, $element[$from_field], $posted[$from_field]);
+    $from_date = date_input_date($field, $instance, $element[$from_field], $item[$from_field]);
     if (!empty($field['settings']['todate'])) {
       $element[$to_field]['#date_timezone'] = $timezone;
       $to_date = date_input_date($field, $instance, $element[$to_field], $merged_date);
diff --git a/date_popup/date_popup.module b/date_popup/date_popup.module
index e9e10c1..586ba05 100644
--- a/date_popup/date_popup.module
+++ b/date_popup/date_popup.module
@@ -179,6 +179,9 @@ function date_popup_time_granularity($element) {
 }
 
 function date_popup_date_format($element) {
+  
+  // if(!array_key_exists('#date_format', $element)) dsm(debug_backtrace(), __FUNCTION__);
+  
   return (date_limit_format($element['#date_format'], date_popup_date_granularity($element)));
 }
 
@@ -195,7 +198,7 @@ function date_popup_element_value_callback($element, $input = FALSE, &$form_stat
 
   $date = NULL;
   $return = $has_time ? array('date' => '', 'time' => '') : array('date' => ''); 
-  if ($input !== FALSE) {
+  if ($input) {
     $return = $input;
     $date = date_popup_input_date($element, $input);  
   }
@@ -204,8 +207,10 @@ function date_popup_element_value_callback($element, $input = FALSE, &$form_stat
   }
   $return['date'] = is_object($date) && !$date->timeOnly ? $date->format(date_popup_date_format($element)) : '';
   $return['time'] = is_object($date) && $has_time ? $date->format(date_popup_time_format($element)) : '';
-  return $return;
 
+  // dsm(get_defined_vars(), __FUNCTION__);
+  
+  return $return;
 }
 
 /**
@@ -219,6 +224,13 @@ function date_popup_element_process($element, $form_state, $form) {
   $element['#tree'] = TRUE;
   $element['#theme_wrappers'] = array('date_popup');
 
+  if (isset($element['#ajax'])) {
+    $element['#ajax'] += array(
+      'trigger_as' => array('name' =>$element['#name']),
+      'event' => 'change',
+    );
+  }
+
   $element['date'] = date_popup_process_date($element);
   $element['time'] = date_popup_process_time($element);
 
@@ -288,7 +300,8 @@ function date_popup_process_date(&$element) {
     '#maxlength' => !empty($element['#maxlength']) ? $element['#maxlength'] : 30,
     '#attributes' => $element['#attributes'],
     '#parents' => $parents,
-    '#name' => array_shift($parents) . '['. implode('][', $parents) .']'
+    '#name' => array_shift($parents) . '['. implode('][', $parents) .']',
+    '#ajax' => !empty($element['#ajax']) ? $element['#ajax'] : FALSE,
   );
   $sub_element['#value'] = $sub_element['#default_value'];
   // TODO, figure out exactly when we want this description. In many places it is not desired.
@@ -334,7 +347,8 @@ function date_popup_process_time(&$element) {
     '#maxlength' => 10,
     '#attributes' => $element['#attributes'],
     '#parents' => $parents,
-    '#name' => array_shift($parents) . '['. implode('][', $parents) .']'
+    '#name' => array_shift($parents) . '['. implode('][', $parents) .']',
+    '#ajax' => !empty($element['#ajax']) ? $element['#ajax'] : FALSE,
   );
   $sub_element['#value'] = $sub_element['#default_value'];
 
@@ -368,9 +382,12 @@ function date_popup_validate($element, &$form_state) {
   $label = t($label);
 
   $input_exists = NULL;
-  $input = drupal_array_get_nested_value($form_state['input'], $element['#parents'], $input_exists);
+  $input = drupal_array_get_nested_value($form_state['values'], $element['#parents'], $input_exists);
   $date = date_popup_input_date($element, $input);
 
+  
+  // dsm(array('input'=>$input, 'element'=>$element, 'date'=>$date), __FUNCTION__);
+  
   // If the field is empty and not required, set it to empty and return.
   // If the field is empty and required, set error message and return.
   $error_field = implode('][', $element['#parents']);
@@ -434,6 +451,9 @@ function date_popup_input_date($element, $input, $auto_complete = FALSE) {
   $datetime = $input['date'];
   $datetime .= $has_time ? ' ' . $input['time'] : '';
   $date = new DateObject($datetime, $element['#date_timezone'], $format);
+  
+  // dsm(get_defined_vars(), __FUNCTION__);
+  
   if (is_object($date)) {
     $date->limitGranularity($granularity);
     if ($date->validGranularity($granularity, $flexible)) {
-- 
1.7.1

